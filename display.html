<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Club Queue Board</title>
  <style>
    :root{
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      --bg:#0b0f14;
      --panel:#0f1622;
      --panel2:#0c131e;
      --border:#223246;
      --text:#e8eef6;
      --muted:#9bb0cc;
      --accent:#24A0CD;
      --good:#00e36a;
      --warn:#fbbf24;
      --arr:#a78bfa;
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --r: 18px;
    }
    body{ margin:0; background:var(--bg); color:var(--text); padding:18px; }
    .wrap{ max-width: 1200px; margin:0 auto; display:grid; gap:14px; }

    header{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      padding: 6px 2px;
    }
    .title{
      display:flex; flex-direction:column; gap:2px;
    }
    h1{ margin:0; font-size: 20px; letter-spacing:.2px; }
    .sub{ color:var(--muted); font-size: 12px; }

    .controls{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
    }
    .chip{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: 999px;
      padding: 8px 12px;
      display:flex; gap:10px; align-items:center;
      box-shadow: var(--shadow);
    }
    .chip label{ font-size:12px; color:var(--muted); }
    select{
      background: transparent;
      color: var(--text);
      border: 0;
      outline: none;
      font-weight: 800;
      letter-spacing:.2px;
      font-size: 13px;
      appearance: none;
      padding-right: 14px;
      cursor:pointer;
    }
    .caret{
      width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:6px solid var(--muted);
      margin-left:-6px;
      pointer-events:none;
    }
    .clock{
      font-variant-numeric: tabular-nums;
      font-weight: 900;
      font-size: 16px;
      letter-spacing:.3px;
    }
    .status{
      font-size:12px; color:var(--muted);
      margin-left: 8px;
    }

    .board{
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid var(--border);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .row{
      display:grid;
      grid-template-columns: 170px 1fr 120px;
      gap: 10px;
      padding: 14px 16px;
      align-items:center;
      border-top:1px solid rgba(255,255,255,.06);
    }
    .row:first-child{ border-top:0; }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight: 900;
      letter-spacing:.25px;
      font-size:12px;
      color: var(--muted);
      text-transform:uppercase;
    }
    .dot{ width:10px; height:10px; border-radius:99px; background:var(--accent); }
    .dot.current{ background: var(--good); }
    .dot.next{ background: var(--warn); }
    .dot.arr{ background: var(--arr); }

    .time{
      font-variant-numeric: tabular-nums;
      font-weight: 900;
      letter-spacing:.4px;
      font-size: 16px;
    }
    .club{
      font-weight: 900;
      font-size: 22px;
      letter-spacing:.2px;
      line-height: 1.1;
      word-break: break-word;
    }
    .mins{
      text-align:right;
      font-variant-numeric: tabular-nums;
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
    }

    /* Prominent CURRENT row */
    .row.current{
      padding: 22px 18px;
      grid-template-columns: 220px 1fr 140px;
      background: rgba(0, 227, 106, .06);
      border-top: 0;
      position: relative;
    }
    .row.current .time{ font-size: 22px; }
    .row.current .club{ font-size: 40px; }
    .row.current .mins{ font-size: 13px; }

    .empty{
      padding: 18px;
      color: var(--muted);
      font-size: 14px;
    }

    .footer{
      display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap;
      color: var(--muted);
      font-size: 12px;
      padding: 0 2px;
    }
    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    @media (max-width: 900px){
      .row, .row.current{
        grid-template-columns: 1fr;
      }
      .mins{ text-align:left; }
      .controls{ justify-content:flex-start; }
      .row.current .club{ font-size: 34px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Club Queue Board</h1>
        <div class="sub">Live schedule • Current, Next, Arriving</div>
      </div>

      <div class="controls">
        <div class="chip">
          <label for="daySel">Day</label>
          <select id="daySel"></select>
          <div class="caret" aria-hidden="true"></div>
        </div>

        <div class="chip">
          <div class="clock" id="clock">--:--:--</div>
          <div class="status" id="status">Loading…</div>
        </div>
      </div>
    </header>

    <div class="board" id="board">
      <div class="empty">Loading schedule…</div>
    </div>

    <div class="footer">
      <div>Source: <a id="srcLink" href="#" target="_blank" rel="noreferrer">CSV</a></div>
      <div id="lastUpdated">Last update: —</div>
    </div>
  </div>

<script>
/**
 * CONFIG
 * - Column F is Day
 * - Column G is Time Slot
 * - Club name column is auto-detected (or set explicitly)
 */
const CONFIG = {
  CSV_URL: "https://docs.google.com/spreadsheets/d/e/2PACX-1vQs88rR8aIqdDYOrpAY5-OSEAxOKAKJAAiSxcmqPI92Vk3kNFEb0w2k8n4oSBXadinF6-8d7jteB4mH/pub?gid=0&single=true&output=csv",
  TIMEZONE: "America/New_York",

  // Header names (preferred). If your headers differ, adjust these.
  DAY_HEADER: "Assigned Date",     // Column F
  TIME_HEADER: "Assigned Time",    // Column G

  // Optional: if your club column header is known, set it.
  // Otherwise, we'll auto-detect from common names AND fall back to "first non-empty text column" excluding day/time.
  CLUB_HEADER: "Clubs",                 // e.g. "Club"

  DEFAULT_SLOT_MINUTES: 10,
  FETCH_EVERY_MS: 300000,
  CLOCK_TICK_MS: 1000,

  // If there is no truly "in-progress" slot, show the next upcoming as CURRENT
  CURRENT_FALLS_FORWARD: true
};

const el = (id) => document.getElementById(id);
el("srcLink").href = CONFIG.CSV_URL;

/** Time helpers */
function nowInTZ() {
  return new Date(new Date().toLocaleString("en-US", { timeZone: CONFIG.TIMEZONE }));
}

/** CSV parser (handles quotes, commas, newlines) */
function parseCSV(text) {
  const rows = [];
  let row = [], cur = "", inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i+1];

    if (c === '"' && inQuotes && next === '"') { cur += '"'; i++; continue; }
    if (c === '"') { inQuotes = !inQuotes; continue; }

    if (!inQuotes && c === ",") { row.push(cur); cur = ""; continue; }
    if (!inQuotes && c === "\n") { row.push(cur); rows.push(row); row = []; cur = ""; continue; }
    if (c === "\r") continue;

    cur += c;
  }
  row.push(cur);
  rows.push(row);
  return rows.filter(r => r.some(cell => (cell || "").trim() !== ""));
}

function normalizeHeader(h) {
  return (h || "").trim().toLowerCase().replace(/\s+/g, " ");
}

function findHeaderIndex(headers, candidates) {
  const map = headers.map(normalizeHeader);
  for (const cand of candidates) {
    const idx = map.indexOf(normalizeHeader(cand));
    if (idx !== -1) return idx;
  }
  return -1;
}

function parseTimeOnDate(timeStr, baseDate) {
  if (!timeStr) return null;
  const s = String(timeStr).trim();
  if (!s) return null;

  const m = s.match(/^\s*(\d{1,2})(?::(\d{2}))?\s*([aApP]\.?[mM]\.?)?\s*$/);
  if (!m) return null;

  let hh = parseInt(m[1], 10);
  const mm = parseInt(m[2] || "0", 10);
  const ampm = (m[3] || "").toLowerCase().replace(/\./g, "");

  if (ampm === "pm" && hh < 12) hh += 12;
  if (ampm === "am" && hh === 12) hh = 0;

  const d = new Date(baseDate);
  d.setHours(hh, mm, 0, 0);
  return d;
}

function parseTimeRange(rangeStr, baseDate) {
  if (!rangeStr) return { start: null, end: null, label: "" };
  const raw = String(rangeStr).trim();

  const parts = raw.split(/[-–—]/).map(x => x.trim()).filter(Boolean);
  if (parts.length >= 2) {
    const start = parseTimeOnDate(parts[0], baseDate);
    const end = parseTimeOnDate(parts[1], baseDate);
    return { start, end, label: raw };
  }
  const start = parseTimeOnDate(raw, baseDate);
  let end = null;
  if (start) {
    end = new Date(start);
    end.setMinutes(end.getMinutes() + CONFIG.DEFAULT_SLOT_MINUTES);
  }
  return { start, end, label: raw };
}

function formatRangeLabel(label, start, end) {
  if (label) return label;
  if (!start) return "—";
  const opts = { hour: "numeric", minute: "2-digit" };
  const a = start.toLocaleTimeString("en-US", opts);
  const b = end ? end.toLocaleTimeString("en-US", opts) : "";
  return b ? `${a} - ${b}` : a;
}

function minutesUntil(ts, now) {
  const diffMs = ts - now;
  const mins = Math.round(diffMs / 60000);
  if (mins <= 0) return "Now";
  if (mins === 1) return "1 min";
  return `${mins} mins`;
}

function setStatus(text) { el("status").textContent = text; }

/** Dropdown persistence */
const DAY_STORAGE_KEY = "clubQueueSelectedDay";

function getSavedDay() {
  return localStorage.getItem(DAY_STORAGE_KEY) || "";
}
function saveDay(v) {
  localStorage.setItem(DAY_STORAGE_KEY, v);
}

/** Column mapping */
function inferColumns(headers, sampleRows) {
  const dayIdx = findHeaderIndex(headers, [CONFIG.DAY_HEADER, "day", "date", "assigned date"]);
  const timeIdx = findHeaderIndex(headers, [CONFIG.TIME_HEADER, "time", "time slot", "timeslot", "slot", "assigned time"]);

  // Try explicit club header
  let clubIdx = CONFIG.CLUB_HEADER
    ? findHeaderIndex(headers, [CONFIG.CLUB_HEADER])
    : findHeaderIndex(headers, ["club", "club name", "organization", "group", "activity", "name"]);

  // If still unknown, fall back: pick a column that looks like club names (texty, not sponsor/co-sponsor/etc.)
  if (clubIdx === -1) {
    const blocked = new Set([dayIdx, timeIdx].filter(i => i !== -1));
    const bannedHeaders = ["sponsor", "co-sponsor", "roster", "size"];
    const headerNorm = headers.map(normalizeHeader);

    // score each column by how many sample rows have a non-empty value
    let best = { idx: -1, score: -1 };
    for (let i = 0; i < headers.length; i++) {
      if (blocked.has(i)) continue;
      if (bannedHeaders.some(b => headerNorm[i].includes(b))) continue;

      let score = 0;
      for (const r of sampleRows) {
        const v = (r[i] || "").trim();
        if (v && v.length >= 2) score++;
      }
      if (score > best.score) best = { idx: i, score };
    }
    clubIdx = best.idx;
  }

  return { dayIdx, timeIdx, clubIdx };
}

/** Render board */
function renderBoard({ current, next, arriving, selectedDay, now }) {
  const board = el("board");
  const fmtNow = now.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit", second:"2-digit" });

  if (!current && !next && !arriving) {
    board.innerHTML = `<div class="empty">No slots found for <b>${escapeHtml(selectedDay || "this day")}</b>.</div>`;
    return;
  }

  const rowHTML = (kind, item) => {
    const dotClass = kind === "CURRENT" ? "current" : (kind === "NEXT" ? "next" : "arr");
    const badgeDot = `<span class="dot ${dotClass}"></span>`;
    const minsText = item
      ? (kind === "CURRENT"
          ? (item.end ? minutesUntil(item.end.getTime(), now.getTime()) + " left" : "Now")
          : minutesUntil(item.start.getTime(), now.getTime()))
      : "—";

    const cls = kind === "CURRENT" ? "row current" : "row";
    if (!item) {
      return `
        <div class="${cls}">
          <div>
            <div class="badge">${badgeDot} ${kind}</div>
            <div class="time">—</div>
          </div>
          <div class="club">—</div>
          <div class="mins">${minsText}</div>
        </div>
      `;
    }

    return `
      <div class="${cls}">
        <div>
          <div class="badge">${badgeDot} ${kind}</div>
          <div class="time">${escapeHtml(item.timeLabel)}</div>
        </div>
        <div class="club">${escapeHtml(item.club)}</div>
        <div class="mins">${escapeHtml(minsText)}</div>
      </div>
    `;
  };

  board.innerHTML =
    rowHTML("CURRENT", current) +
    rowHTML("NEXT", next) +
    rowHTML("ARRIVING", arriving);
}

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/** Main fetch+update */
let lastDaysSignature = "";

async function fetchAndUpdate() {
  setStatus("Refreshing…");
  try {
    const url = CONFIG.CSV_URL + (CONFIG.CSV_URL.includes("?") ? "&" : "?") + "cb=" + Date.now();
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Fetch failed (${res.status})`);
    const text = await res.text();

    const rows = parseCSV(text);
    if (rows.length < 2) throw new Error("CSV has no data rows.");

    const headers = rows[0];
    const sampleRows = rows.slice(1, 8);

    const { dayIdx, timeIdx, clubIdx } = inferColumns(headers, sampleRows);

    // Column F/G should exist; if header matching fails, we still try to fall back to F/G positions
    const fallbackDayIdx = 5;  // Col F
    const fallbackTimeIdx = 6; // Col G

    const finalDayIdx = (dayIdx !== -1) ? dayIdx : fallbackDayIdx;
    const finalTimeIdx = (timeIdx !== -1) ? timeIdx : fallbackTimeIdx;

    if (clubIdx === -1) {
      throw new Error(
        `Could not identify the Club column. ` +
        `Try setting CONFIG.CLUB_HEADER to your exact club column header. ` +
        `Headers seen: ${headers.join(", ")}`
      );
    }

    const baseNow = nowInTZ();

    // Build list of days (dropdown options)
    const daySet = new Set();
    for (const r of rows.slice(1)) {
      const d = (r[finalDayIdx] || "").trim();
      if (d) daySet.add(d);
    }
    const days = Array.from(daySet);

    // Keep dropdown stable (only repopulate when set changes)
    const sig = days.slice().sort().join("||");
    if (sig !== lastDaysSignature) {
      lastDaysSignature = sig;
      populateDayDropdown(days);
    }

    // Determine selected day
    const selEl = el("daySel");
    let selectedDay = selEl.value || getSavedDay();

    // If none selected yet, pick first day (sorted)
    if (!selectedDay) {
      selectedDay = (days.slice().sort()[0] || "");
    }

    // If selected day no longer exists, fall back
    if (selectedDay && !daySet.has(selectedDay)) {
      selectedDay = (days.slice().sort()[0] || "");
    }

    if (selEl.value !== selectedDay) selEl.value = selectedDay;
    saveDay(selectedDay);

    // Build schedule rows filtered by day
    const data = rows.slice(1).map(r => {
      const day = (r[finalDayIdx] || "").trim();
      if (selectedDay && day !== selectedDay) return null;

      const timeStr = (r[finalTimeIdx] || "").trim();
      const club = (r[clubIdx] || "").trim();
      if (!timeStr || !club) return null;

      const parsed = parseTimeRange(timeStr, baseNow);
      if (!parsed.start) return null;

      return {
        club,
        start: parsed.start,
        end: parsed.end,
        timeLabel: formatRangeLabel(parsed.label, parsed.start, parsed.end)
      };
    }).filter(Boolean);

    data.sort((a,b) => a.start - b.start);

    const now = baseNow.getTime();

    // Find true current (in-progress)
    let current = data.find(item => {
      const s = item.start.getTime();
      const e = (item.end ? item.end.getTime() : s);
      return s <= now && now < e;
    }) || null;

    // If not in-progress, optionally "fall forward" to next upcoming
    if (!current && CONFIG.CURRENT_FALLS_FORWARD) {
      current = data.find(item => item.start.getTime() > now) || null;
    }

    // Determine next and arriving relative to "current" (or from now if no current)
    let next = null, arriving = null;

    if (current) {
      const idx = data.indexOf(current);
      next = data[idx + 1] || null;
      arriving = data[idx + 2] || null;
    } else {
      const future = data.filter(item => item.start.getTime() > now);
      next = future[0] || null;
      arriving = future[1] || null;
    }

    renderBoard({ current, next, arriving, selectedDay, now: baseNow });

    el("lastUpdated").textContent =
      "Last update: " + new Date().toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit", second:"2-digit" });

    setStatus(`OK • ${data.length} slots • ${selectedDay || "All days"}`);

  } catch (err) {
    setStatus("Error");
    el("board").innerHTML =
      `<div class="empty"><b>Could not load queue.</b><br>${escapeHtml(err.message || String(err))}</div>`;
  }
}

/** Dropdown */
function populateDayDropdown(days) {
  const sel = el("daySel");
  const saved = getSavedDay();

  const sorted = days.slice().sort((a,b) => a.localeCompare(b));
  sel.innerHTML = "";

  // If no days found, still show placeholder
  if (!sorted.length) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "No days";
    sel.appendChild(opt);
    return;
  }

  for (const d of sorted) {
    const opt = document.createElement("option");
    opt.value = d;
    opt.textContent = d;
    sel.appendChild(opt);
  }

  if (saved && sorted.includes(saved)) {
    sel.value = saved;
  } else {
    sel.value = sorted[0];
  }
}

/** Clock */
function tickClock() {
  const now = nowInTZ();
  el("clock").textContent = now.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit", second:"2-digit" });
}

el("daySel").addEventListener("change", () => {
  saveDay(el("daySel").value);
  fetchAndUpdate();
});

/** Init */
tickClock();
setInterval(tickClock, CONFIG.CLOCK_TICK_MS);
fetchAndUpdate();
setInterval(fetchAndUpdate, CONFIG.FETCH_EVERY_MS);
</script>
</body>
</html>
